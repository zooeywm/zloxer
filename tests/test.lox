fun stressTest(name, limit) {
  print "=== stressTest begin ===";
  print "name: " + name;
  print "limit: " + limit;

  var counter = 0;
  var sum = 0;
  var last = nil;

  {
    var counter = 100; print "shadowed counter (outer block): " + counter;

    {
      var counter = 200;
      print "shadowed counter (inner block): " + counter;
    }

    print "counter after inner block: " + counter;
  }

  print "counter after blocks: " + counter;

  // while + if + break
  while (counter < limit) {
    sum = sum + counter;

    if (counter > limit / 2) {
      print "halfway reached at: " + counter;
    }

    last = counter;
    counter = counter + 1;

    if (counter > limit + 2) {
      break;
    }
  }

  print "loop finished";
  print "sum: " + sum;
  print "last value: " + last;

  var outer = 0;
  for (var i = 0; i < 3; i = i + 1) {
    print "for i = " + i;

    var inner = 0;
    while (inner < 2) {
      print "  inner = " + inner;
      outer = outer + 1;
      inner = inner + 1;
    }
  }

  print "outer count: " + outer;

  if (sum > 50) {
    print "sum is large";
  } else {
    print "sum is small";
  }

  print "=== stressTest end ===";
}

stressTest("TestRun", 8);

fun multiParamFunction(a, b, c, d, e) {

}

print stressTest;
print multiParamFunction;

fun fib(n) {
  if (n <= 1) return n;
  return fib(n - 2) + fib(n - 1);
}

var start = clock();
for (var i = 0; i < 20; i = i + 1) {
  fib(i);
}
var elapsed = clock() - start;
print elapsed * 1000 + "ms";

fun makeCounter() {
  var i = 0;
  fun count() {
    i = i + 1;
    print i;
  }

  return count;
}

var counter = makeCounter();
counter(); // "1".
counter(); // "2".

// Advanced closure example with parameters
fun makeAdder(x) {
  fun adder(y) {
    return x + y;
  }
  return adder;
}

// Create a function that adds 5 to its argument
var add5 = makeAdder(5);
print add5(2); // prints "7"

// Create a function that adds 10 to its argument
var add10 = makeAdder(10);
print add10(2); // prints "12"

// Demonstrate that each closure maintains its own captured variable
var x = 1;
fun foo() {
  var x = 2;
  fun bar() {
    print x; // prints the local x (2), not the global one (1)
  }
  return bar;
}

var closure = foo();
closure(); // prints "2"
print x;    // prints "1"

// Example of closure with multiple captured variables
fun createMultiplierAndAdder(multiplier, addend) {
  fun mulAdder(value) {
    return value * multiplier + addend;
  }

  return mulAdder;
}

var multiplyBy2Add3 = createMultiplierAndAdder(2, 3);
var multiplyBy10Minus5 = createMultiplierAndAdder(10, -5);

print multiplyBy2Add3(5);   // prints "13" (5*2+3)
print multiplyBy10Minus5(3); // prints "25" (3*10-5)

fun scope(a) {
  print "before shadow: " + a;
  // Shadow a value
  var a = "local";
  print "after shadow: " + a;
  print a;
}

scope("abc");
